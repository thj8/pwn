# 思路
- FILE的flag添加line属性，有\n的时候就会输出
- 把fileno3-->1,标准输出stdout
- %9$p等泄漏栈，程序，libc基地址
- 整体思路：1. 泄露地址 → 2. 计算栈布局 → 3. 覆盖fprint返回地址 → 4. 构造ROP链 → 5. 触发Shell。


# 知识点
## 3c84--> 3e84
增加了一个flag_IO_LINE_BUF (0x0200) : 启用行缓冲模式。在这种模式下，每次换行或缓冲区满时进行刷新。


![](https://r2.20161023.xyz/pic/20250513211532826.png)

![](https://r2.20161023.xyz/pic/20250513211630246.png)

![](https://r2.20161023.xyz/pic/20250513211706383.png)

## 112偏移量怎么算？
file_offset=0x56166dc55720-0x56166dc556b0=0x70=112

![](https://r2.20161023.xyz/pic/20250513211824430.png)


## 死循环，没有退出怎么getshell
利用格式化字符串，改写0x7ffd8a2bf828为ret的地址（测试发现只能为程序本身的ret，原因如下一节）
![](https://r2.20161023.xyz/pic/20250514165029342.png)

## 最后一步， 为什么不能多次格式化字符串，覆盖rip到栈上
栈上面布局
```
pop_rdi_ret
bin_sh_addr
system_addr
```
因为fprint函数返回值为0x0564253dfe386,是一个app的地址，只有一次机会写入，
分多次写，每次写一个字节，双字节的话，只能覆盖最后几个字节，导致下一次fprint的时候程序异常
写入lln的时候，debug时发生异常也无法使用
![](https://r2.20161023.xyz/pic/20250514164759510.png)


# getshell
![](https://r2.20161023.xyz/pic/20250514165446180.png)